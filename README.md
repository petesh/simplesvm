Stub import library

this is a sample import library: svm.d which declares a couple of
c++ routines that are defined in svm\_cpp.o as well as the related
structs that are needed to use it.

The svm\_cpp.cpp contains the c++ code that interfaces with the .d
routines. These are stub routines that only set constant values no
matter the input.

The svm\_use.d file is a couple of main routines containing code that
makes use of the structs and invokes the C++ routines.

The Makefile stitches it all together. The top rule tries to run the
program (emulating rdmd's behaviour). The program is called svm\_use

svm\_use depends on it's own .d file, the svm\_cpp.o file (generated
from the .cpp file), the svm.o file (generated from svm.d) and the
dummymain.o file (auto-generated by the dummymain.d: rule (this
dependency duplicates the --main option passed to rdmd).

The compilation rule for svm\_use is to use dmd to compile all the
dependencies($^ == svm\_use.d svm\_cpp.o svm.o dummymain.o) into the
file svm\_use($@), and to link in the C++ runtime library (-L-lstdc++ -
this is dynamic because I hate static linking).

There is a rule for compiling svm\_cpp.o from svm\_cpp.cpp. All it does
is compile all the dependent files ($^ == svm\_cpp.cpp) into
svm\_cpp.o($@)

Then there is a rule for all files ending in the extension .o(%.o).
This rule only comes into effect when there's a .d file who's basename
matches the basename of the targetted .o file. e.g. If we need to build
a file called svm.o and there's a file called svm.d, then we can use
this rule to build that file.

Finally there's a rule to generate the dummymain.d file if it doesn't
exist. This rule simply echoes a dummy main routine into the file called
dummymain.d($@).

